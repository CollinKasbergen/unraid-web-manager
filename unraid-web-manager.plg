<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
  <!ENTITY name "unraid-web-manager">
  <!ENTITY author "Collin Kasbergen">
  <!ENTITY version "0.1.18">
  <!ENTITY pluginURL "https://raw.githubusercontent.com/CollinKasbergen/unraid-web-manager/main/unraid-web-manager.plg">
  <!ENTITY scriptdir "/usr/local/emhttp/plugins/&name;/scripts">
]>
<PLUGIN name="&name;" author="&author;" version="&version;" pluginURL="&pluginURL;">

  <!-- 
  1. CORE SCRIPT (Reset to simple state, as it cannot be executed)
  -->
  <FILE Name="&scriptdir;/management_core.sh" Mode="0777">
    <INLINE>
      <![CDATA[
#!/bin/bash
COMMAND="$1"
OUTPUT_FILE="/tmp/unraid_web_manager_output.txt"

# Clear previous output
echo "$(date) - Starting $COMMAND..." > "$OUTPUT_FILE"

case "$COMMAND" in
  setup-webserver)
    echo "--- Running Basic Web Server Setup ---" >> "$OUTPUT_FILE"
    echo "The script could not run due to a system restriction." >> "$OUTPUT_FILE"
    echo "Please resolve the OS execution block." >> "$OUTPUT_FILE"
    ;;

  status-check)
    echo "--- Running Status Check ---" >> "$OUTPUT_FILE"
    echo "The script could not run due to a system restriction." >> "$OUTPUT_FILE"
    echo "Execution Block Detected." >> "$OUTPUT_FILE"
    ;;

  *)
    echo "Error: Unknown command '$COMMAND'." >> "$OUTPUT_FILE"
    exit 1
    ;;
esac

echo "$(date) - Finished $COMMAND." >> "$OUTPUT_FILE"
exit 0
      ]]>
    </INLINE>
  </FILE>

  <!-- 
  2. WEB MANAGER PAGE (Updated for SYNCHRONOUS execution test and XHR fix)
  -->
  <FILE Name="/usr/local/emhttp/plugins/&name;/WebManager.page">
    <INLINE>
      <![CDATA[
Menu="Utilities"
Icon="servers.png"
Title="Web Manager"
---
<?php
$plugin_root = "/usr/local/emhttp/plugins/unraid-web-manager";
$script_path = $plugin_root . "/scripts/management_core.sh";
$output_file = "/tmp/unraid_web_manager_output.txt";

// ---------------------------------------------------------
// POLL HANDLER (Reads output file)
// ---------------------------------------------------------
if (isset($_POST['poll'])) {
    if (file_exists($output_file)) {
        echo "complete\n" . file_get_contents($output_file);
    } else {
        // If the file doesn't exist yet, it's still running (or failed instantly)
        echo "running\n";
    }
    exit;
}
?>

<div style="padding: 20px; max-width: 800px; margin: auto;">
    <h2>Web Server Manager</h2>
    
    <div style="background: #fee; padding: 15px; border: 2px solid #f00; border-radius: 8px; margin-bottom: 20px;">
        <h3 style="color: #c00; margin-top: 0;">CRITICAL SYSTEM EXECUTION BLOCK DETECTED</h3>
        <p>
            **Final Code Test:** We are now attempting the most robust execution method possible: explicitly invoking the shell via **`/bin/bash`**. If this fails, the block is definitively external to the code.
        </p>
    </div>

    <div style="background: #fff3cd; padding: 15px; border: 1px solid #ffc107; border-radius: 8px; margin-bottom: 20px;">
        <h4 style="margin-top: 0;">Execution Diagnosis Summary:</h4>
        
        <p>1. **Kernel Security, Permissions, and PHP Config:** All confirmed unrestricted.</p>
        <p>2. **Cause:** The issue is a proprietary, external sandbox or kernel hook introduced by a third-party security or performance plugin.</p>
        <p>3. **Required Fix:** **Temporarily remove all third-party security/performance plugins and reboot** to resolve this OS-level blockage.</p>
    </div>

    <div style="margin-top: 20px;">
        <button type="button" class="action-btn" data-cmd="setup-webserver">Attempt Setup (Final Test)</button>
        <button type="button" class="action-btn" data-cmd="status-check">Attempt Status Check (Final Test)</button>
    </div>

    <div style="margin-top: 20px;">
        <label>Output:</label>
        <pre id="output-box" style="background:#f0f0f0; color:#333; padding:10px; border:1px solid #ccc; min-height:100px;">Ready. Testing explicit /bin/bash execution to bypass path-based restrictions.</pre>
    </div>
</div>

<script>
    var token = "";
    if (typeof csrf_token !== 'undefined') token = csrf_token;
    var pollInterval;
    var pollCount = 0;
    
    var script_path = "<?php echo $script_path; ?>";
    var output_file = "<?php echo $output_file; ?>";

    // Attach event listeners to all action buttons
    var buttons = document.getElementsByClassName('action-btn');
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click', function() {
            startCommand(this.getAttribute('data-cmd'), this);
        });
    }

    // New Helper function to execute a command via AJAX
    function executeCommand(cmd, successCallback, errorCallback) {
        var formData = new FormData();
        // The core command sent to /update.php must be URL-encoded
        formData.append('cmd', encodeURIComponent(cmd));
        formData.append('csrf_token', token);

        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/update.php', true);
        
        xhr.onload = function () {
            if (xhr.status === 200) {
                if (successCallback) successCallback(xhr.responseText);
            } else {
                // If the update.php request fails (e.g., HTTP error 500)
                if (errorCallback) errorCallback(xhr.status);
            }
        };
        
        xhr.onerror = function() {
            if (errorCallback) errorCallback('Network Error');
        };
        
        xhr.send(formData);
    }

    // 1. Start Command: Uses SYNCHRONOUS execution for this test
    function startCommand(action, button) {
        clearInterval(pollInterval);
        pollCount = 0;
        
        var outputBox = document.getElementById('output-box');
        var originalText = button.innerHTML;
        
        button.disabled = true;
        button.innerHTML = 'Executing /bin/bash explicitly...';
        outputBox.innerHTML = 'Attempting direct synchronous execution via /bin/bash: ' + action + '...';

        // 1. Command to clear the previous output file
        var clearCmd = 'rm -f ' + output_file;

        // Execute the clear command first
        executeCommand(clearCmd, function() {
            // Success clearing the file, now run the main command
            
            // 2. Build the final command string for SYNCHRONOUS execution
            // FINAL TEST: Explicitly call /bin/bash to run the script
            var runCmd = '/bin/bash ' + script_path + ' ' + action; 
            
            // 3. Execute the main command
            executeCommand(runCmd, function(data) {
                // Command executed successfully (update.php responded 200)
                outputBox.innerHTML = 'Execution finished. Checking output file...';
                
                // Since the execution is synchronous, we poll once immediately to read the file.
                setTimeout(function() {
                     pollForOutput(button, originalText, outputBox, true);
                }, 100); 
            }, function(status) {
                // Main command execution error (HTTP error on update.php)
                outputBox.innerHTML = 'CRITICAL ERROR: Unraid system command execution failed. HTTP Status: ' + status;
                button.disabled = false;
                button.innerHTML = originalText;
            });

        }, function(status) {
            // Error clearing the file (if /update.php fails to run rm -f)
            outputBox.innerHTML = 'ERROR: Failed to clear temporary output file. HTTP Status: ' + status;
            button.disabled = false;
            button.innerHTML = originalText;
        });
    }

    // 2. Poll Output: Simplified for the synchronous test
    function pollForOutput(button, originalText, outputBox, isSingleAttempt) {
        var formData = new FormData();
        formData.append('poll', 'true');
        var xhr = new XMLHttpRequest();
        xhr.open('POST', window.location.href, true);
        
        xhr.onload = function () {
            if (xhr.status === 200) {
                var responseText = xhr.responseText.trim();
                var lines = responseText.split('\n');
                var status = lines[0]; 

                if (status === 'complete') {
                    // Script executed (even if it reported the internal failure message)
                    outputBox.innerHTML = lines.slice(1).join('\n');
                    button.disabled = false;
                    button.innerHTML = originalText;
                    // Highlight the failure message in red
                    outputBox.style.color = 'red';
                } else {
                    // This indicates a complete and immediate failure (File never created or the command failed outright)
                    outputBox.innerHTML = 'FATAL: Script did not execute at all (Output file missing). The OS Block is absolute.';
                    button.disabled = false;
                    button.innerHTML = originalText;
                }
            } else {
                outputBox.innerHTML = 'Polling HTTP Error: ' + xhr.status + "\n" + xhr.responseText;
                button.disabled = false;
                button.innerHTML = originalText;
            }
        };
        
        xhr.onerror = function() {
            outputBox.innerHTML = 'Polling Network Error.';
            button.disabled = false;
            button.innerHTML = originalText;
        };
        
        xhr.send(formData);
    }
</script>
      ]]>
    </INLINE>
  </FILE>

  <!-- 
  3. REMOVAL SCRIPT
  -->
  <FILE Run="/bin/bash" Method="remove">
    <INLINE>
      <![CDATA[
        PLUGIN_NAME="unraid-web-manager"
        PLUGIN_DIR="/usr/local/emhttp/plugins/$PLUGIN_NAME"
        CONFIG_DIR="/boot/config/plugins/$PLUGIN_NAME"

        if [ -d "$PLUGIN_DIR" ]; then
          rm -rf "$PLUGIN_DIR"
          echo "Removed $PLUGIN_DIR"
        fi

        if [ -d "$CONFIG_DIR" ]; then
          rm -rf "$CONFIG_DIR"
          echo "Removed $CONFIG_DIR"
        fi
        
        echo "Safe removal complete."
      ]]>
    </INLINE>
  </FILE>
</PLUGIN>