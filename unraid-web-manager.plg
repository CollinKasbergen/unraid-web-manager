<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
  <!ENTITY name "unraid-web-manager">
  <!ENTITY author "Collin Kasbergen">
  <!ENTITY version "0.1.5">
  <!ENTITY pluginURL "https://raw.githubusercontent.com/CollinKasbergen/unraid-web-manager/main/unraid-web-manager.plg">
  <!ENTITY scriptdir "/usr/local/emhttp/plugins/&name;/scripts">
]>
<PLUGIN name="&name;" author="&author;" version="&version;" pluginURL="&pluginURL;">

  <!-- 
  1. CORE SCRIPT (Writes output to a temp file for PHP to read)
  -->
  <FILE Name="&scriptdir;/management_core.sh" Mode="0777">
    <INLINE>
      <![CDATA[
#!/bin/bash
COMMAND="$1"
OUTPUT_FILE="/tmp/unraid_web_manager_output.txt"

# Clear previous output and set a start marker
echo "$(date) - Starting $COMMAND..." > "$OUTPUT_FILE"

case "$COMMAND" in
  setup-webserver)
    echo "--- Running Basic Web Server Setup ---" >> "$OUTPUT_FILE"
    echo "Simulating server configuration..." >> "$OUTPUT_FILE"
    echo "Setup complete. Status: Success" >> "$OUTPUT_FILE"
    ;;

  status-check)
    echo "--- Running Status Check ---" >> "$OUTPUT_FILE"
    echo "Simulating server status check: Online." >> "$OUTPUT_FILE"
    ;;

  *)
    echo "Error: Unknown command '$COMMAND'." >> "$OUTPUT_FILE"
    exit 1
    ;;
esac

echo "$(date) - Finished $COMMAND." >> "$OUTPUT_FILE"
exit 0
      ]]>
    </INLINE>
  </FILE>

  <!-- 
  2. EXECUTE SCRIPT HELPER (Uses secure, non-blocking exec_cmd)
  This page is only called via AJAX to START the script.
  -->
  <FILE Name="/usr/local/emhttp/plugins/&name;/ExecuteScript.php">
    <INLINE>
      <![CDATA[
<?php
// Ensure this script can only be called from a POST request
if ($_SERVER['REQUEST_METHOD'] !== 'POST' || !isset($_POST['action'])) {
    http_response_code(403);
    echo "Forbidden";
    exit;
}

$script_path = "/usr/local/emhttp/plugins/unraid-web-manager/scripts/management_core.sh";
$output_file = "/tmp/unraid_web_manager_output.txt";
$command = escapeshellarg($_POST['action']);

// 1. Self-Healing
shell_exec("dos2unix " . escapeshellarg($script_path) . " 2>&1");
chmod($script_path, 0777);

// 2. Clear the previous output file
if (file_exists($output_file)) unlink($output_file);

// 3. Execute the script using the highly stable WebUI function (with background &)
$full_cmd = "$script_path $command &";

// exec_cmd is the most reliable way to run system commands in Unraid's PHP context
exec_cmd($full_cmd);

// Return success immediately, the script is now running in the background
echo "Script successfully initiated: " . $full_cmd;
?>
      ]]>
    </INLINE>
  </FILE>

  <!-- 
  3. WEB MANAGER PAGE (The visible dashboard)
  This page handles the UI, starts the script, and polls the output file.
  -->
  <FILE Name="/usr/local/emhttp/plugins/&name;/WebManager.page">
    <INLINE>
      <![CDATA[
Menu="Utilities"
Icon="servers.png"
Title="Web Manager"
---
<?php
$plugin_root = "/usr/local/emhttp/plugins/unraid-web-manager";
$script_path = $plugin_root . "/scripts/management_core.sh";
$output_file = "/tmp/unraid_web_manager_output.txt";

// ---------------------------------------------------------
// POLL HANDLER (for reading the file only)
// ---------------------------------------------------------
if (isset($_POST['poll'])) {
    if (file_exists($output_file)) {
        // Return output and a flag to stop polling
        echo json_encode(["status" => "complete", "output" => file_get_contents($output_file)]);
        // Optionally clean up the file here: unlink($output_file); 
    } else {
        // Return a flag to keep polling
        echo json_encode(["status" => "running", "output" => "Script is running in the background..."]);
    }
    exit;
}

// Diagnostics for the display page
$file_perms = substr(sprintf('%o', fileperms($script_path)), -4);
$f = file_exists($script_path) ? fopen($script_path, 'r') : null;
$first_line = $f ? fgets($f) : "File not found";
if ($f) fclose($f);
?>

<div style="padding: 20px;">
    <h2>Web Server Manager</h2>
    
    <div style="background: #eef; padding: 10px; border: 1px solid #ccd; margin-bottom: 20px;">
        <strong>Debug Info:</strong><br>
        Script Path: <code><?php echo $script_path; ?></code><br>
        Permissions: <code><?php echo $file_perms; ?></code><br>
        Shebang Check: <code><?php echo htmlspecialchars(trim($first_line)); ?></code>
    </div>

    <div style="margin-top: 20px;">
        <button type="button" class="action-btn" data-cmd="setup-webserver">Setup Web Server</button>
        <button type="button" class="action-btn" data-cmd="status-check">Check Status</button>
    </div>

    <div style="margin-top: 20px;">
        <label>Output:</label>
        <pre id="output-box" style="background:#f0f0f0; color:#333; padding:10px; border:1px solid #ccc; min-height:100px;">Ready.</pre>
    </div>
</div>

<script>
    var token = "";
    if (typeof csrf_token !== 'undefined') token = csrf_token;
    var pollInterval;

    // Attach events to all buttons with class 'action-btn'
    var buttons = document.getElementsByClassName('action-btn');
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click', function() {
            startCommand(this.getAttribute('data-cmd'), this);
        });
    }

    // 1. Start Command: Calls ExecuteScript.php to initiate the background process
    function startCommand(action, button) {
        // Clear previous polling
        clearInterval(pollInterval);
        
        var outputBox = document.getElementById('output-box');
        var originalText = button.innerHTML;
        
        button.disabled = true;
        button.innerHTML = 'Starting...';
        outputBox.innerHTML = 'Initiating command: ' + action + '...';

        var formData = new FormData();
        formData.append('action', action);
        formData.append('csrf_token', token);

        // Fetch to the dedicated ExecuteScript.php file
        fetch('ExecuteScript.php', {
            method: 'POST',
            body: formData
        })
        .then(response => response.text())
        .then(data => {
            // Script initiated successfully. Start polling for results.
            outputBox.innerHTML = 'Script started in background. Polling for output file...';
            button.innerHTML = 'Running...';
            pollInterval = setInterval(pollForOutput, 1000, button, originalText, outputBox); // Poll every second
        })
        .catch(error => {
            outputBox.innerHTML = 'Error initiating script via ExecuteScript.php: ' + error;
            button.disabled = false;
            button.innerHTML = originalText;
        });
    }

    // 2. Poll Output: Repeatedly checks the current page to read the temp file
    function pollForOutput(button, originalText, outputBox) {
        var formData = new FormData();
        formData.append('poll', 'true');
        formData.append('csrf_token', token);

        fetch(window.location.href, { // Posting back to WebManager.page
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'complete') {
                clearInterval(pollInterval);
                outputBox.innerHTML = data.output;
                button.disabled = false;
                button.innerHTML = originalText;
            } else {
                // Still running, update status message
                outputBox.innerHTML += '.'; 
            }
        })
        .catch(error => {
            clearInterval(pollInterval);
            outputBox.innerHTML = 'Polling error: ' + error;
            button.disabled = false;
            button.innerHTML = originalText;
        });
    }
</script>
      ]]>
    </INLINE>
  </FILE>

  <!-- 
  4. REMOVAL SCRIPT
  -->
  <FILE Run="/bin/bash" Method="remove">
    <INLINE>
      <![CDATA[
        PLUGIN_NAME="unraid-web-manager"
        PLUGIN_DIR="/usr/local/emhttp/plugins/$PLUGIN_NAME"
        CONFIG_DIR="/boot/config/plugins/$PLUGIN_NAME"

        if [ -d "$PLUGIN_DIR" ]; then
          rm -rf "$PLUGIN_DIR"
          echo "Removed $PLUGIN_DIR"
        fi

        if [ -d "$CONFIG_DIR" ]; then
          rm -rf "$CONFIG_DIR"
          echo "Removed $CONFIG_DIR"
        fi
        
        echo "Safe removal complete."
      ]]>
    </INLINE>
  </FILE>
</PLUGIN>